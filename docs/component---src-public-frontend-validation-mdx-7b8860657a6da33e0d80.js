(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{JiLu:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return s})),t.d(n,"default",(function(){return m}));var r=t("Fcif"),a=t("+I+c"),o=(t("mXGw"),t("/FXl")),i=t("TjRS"),s=(t("aD51"),{});void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/public/frontend/validation.mdx"}});var c={_frontmatter:s},p=i.a;function m(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(o.b)(p,Object(r.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"form--validation"},"Form & Validation"),Object(o.b)("p",null,"form validation got usually return from server api to validate on typings and before submitting."),Object(o.b)("p",null,"etc:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "object",\n  "properties": {\n    "question": {\n      "type": "string",\n      "required": true,\n      "minLength": 3,\n      "maxLength": 255,\n      "label": "Question"\n    },\n    "attachments": {\n      "type": "array",\n      "of": {\n        "type": "object",\n        "properties": {\n          "id": {\n            "type": "number",\n            "required": true\n          },\n          "file_name": {\n            "type": "string",\n            "required": true\n          }\n        }\n      },\n      "label": "Attachments"\n    }\n  }\n}\n')),Object(o.b)("h2",{id:"boolean"},"Boolean"),Object(o.b)("p",null,"Converting a string type json schema to a yup object will return an object the equivalent of ",Object(o.b)("inlineCode",{parentName:"p"},"yup.boolean()")," with all of the additional validation configuration."),Object(o.b)("h3",{id:"usage"},"Usage"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"import { toYup, BooleanTypeSchema } from '@metafox/json2yup';\nimport * as yup from 'yup';\n\nconst schema: BooleanTypeSchema = {\n  type: 'boolean',\n  strict: true,\n  required: true,\n  errors: {\n    required: 'MY custom required message'\n  }\n};\n\nconst yupSchema = toYup(schema);\n\nconsole.log(yupSchema.isValidSync(true)); //true\nconsole.log(yupSchema.isValidSync(false)); //true\nconsole.log(yupSchema.isValidSync('true')); //false\nconsole.log(yupSchema.isValidSync('false')); //false\n\n// Equivalent to\n\nconst yupBooleanSchema = yup\n  .boolean()\n  .required('My custom required message')\n  .strict(true);\n")),Object(o.b)("h3",{id:"type"},"Type"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"type BooleanTypeSchema = YupTypeSchema & {\n  type: 'boolean';\n  oneOf?: boolean[];\n  notOneOf?: boolean[];\n  nullable?: boolean;\n  errors?: YupTypeErrors & {\n    oneOf?: string;\n    notOneOf?: string;\n  };\n  when?: WhenSchema<BooleanTypeSchema>[];\n};\n")),Object(o.b)("h2",{id:"array"},"Array"),Object(o.b)("p",null,"Converting a string type json schema to a yup object will return an object the equivalent of ",Object(o.b)("inlineCode",{parentName:"p"},"yup.array()")," with all of the additional validation configuration."),Object(o.b)("h3",{id:"usage-1"},"Usage"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"import { toYup, ArrayTypeSchema } from '@metafox/json2yup';\nimport * as yup from 'yup';\n\nconst schema: ArrayTypeSchema = {\n  type: 'array',\n  strict: true,\n  required: true,\n  min: 2,\n  errors: {\n    min: 'My custom min length message',\n    required: 'My custom required message'\n  }\n};\n\nconst yupSchema = toYup(schema);\n\nconsole.log(yupSchema.isValidSync(['Good', 'Morning'])); //true\nconsole.log(yupSchema.isValidSync('Hello')); //false\n\n// Equivalent to\n\nconst yupArraySchema = yup\n  .array()\n  .min(2, 'My custom min length message')\n  .required('My custom required message')\n  .strict(true);\n")),Object(o.b)("h3",{id:"type-1"},"Type"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"type ArrayTypeSchema = YupTypeSchema & {\n  type: 'array';\n  of?: TypeSchemas;\n  min?: number;\n  max?: number;\n  nullable?: boolean;\n  unique?: boolean; // to compare string[], int[]\n  uniqueBy?: string; // to compare complex object\n  errors?: YupTypeErrors & {\n    min?: string;\n    max?: string;\n    unique?: boolean;\n    uniqueBy?: string;\n  };\n  when?: WhenSchema<ArrayTypeSchema>[];\n};\n")),Object(o.b)("h2",{id:"date"},"Date"),Object(o.b)("p",null,"Converting a string type json schema to a yup object will return an object the equivalent of ",Object(o.b)("inlineCode",{parentName:"p"},"yup.date()")," with all of the additional validation configuration."),Object(o.b)("h3",{id:"usage-2"},"Usage"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"import { toYup, DateTypeSchema } from '@metafox/json2yup';\nimport * as yup from 'yup';\n\nconst schema: DateTypeSchema = {\n  type: 'date',\n  strict: true,\n  required: true,\n  min: '2020-01-01',\n  errors: {\n    min: 'MY custom min date message',\n    required: 'MY custom required message'\n  }\n};\n\nconst yupSchema = toYup(schema);\n\nconsole.log(yupSchema.isValidSync('2020-01-02')); //true\nconsole.log(yupSchema.isValidSync('2019-12-31')); //false\n\n// Equivalent to\n\nconst yupDateSchema = yup\n  .date()\n  .min(2, 'My custom min date message')\n  .required('My custom required message')\n  .strict(true);\n")),Object(o.b)("h3",{id:"type-2"},"Type"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"type DateTypeSchema = YupTypeSchema & {\n  type: 'date';\n\n  /**\n   * number: as a unix timestamp in seconds\n   * string: anything parsable by `new Date(string)` e.g. '2020-12-01'\n   */\n  min?: number | string | Reference<number | string>;\n\n  /**\n   * number: as a unix timestamp in seconds\n   * string: anything parsable by `new Date(string)` e.g. '2020-12-01'\n   */\n  max?: number | string | Reference<number | string>;\n\n  nullable?: boolean;\n  errors?: YupTypeErrors & { min?: string; max?: string };\n  when?: WhenSchema<DateTypeSchema>[];\n};\n")),Object(o.b)("h2",{id:"number"},"Number"),Object(o.b)("p",null,"Converting a string type json schema to a yup object will return an object the equivalent of ",Object(o.b)("inlineCode",{parentName:"p"},"yup.number()")," with all of the additional validation configuration."),Object(o.b)("h3",{id:"usage-3"},"Usage"),Object(o.b)("p",null,"For more advanced usage, check out the ",Object(o.b)("a",{parentName:"p",href:"../src/tests/types/number"},"number type test suite"),"."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"import { toYup, NumberTypeSchema } from '@metafox/json2yup';\nimport * as yup from 'yup';\n\nconst schema: NumberTypeSchema = {\n  type: 'number',\n  strict: true,\n  required: true,\n  min: 5,\n  errors: {\n    min: 'My custom min value message',\n    required: 'My custom required message'\n  }\n};\n\nconst yupSchema = toYup(schema);\n\nconsole.log(yupSchema.isValidSync(5)); //true\nconsole.log(yupSchema.isValidSync(1)); //false\n\n// Equivalent to\n\nconst yupNumberSchema = yup\n  .number()\n  .min(5, 'My custom min value message')\n  .required('My custom required message')\n  .strict(true);\n")),Object(o.b)("h3",{id:"type-3"},"Type"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"type NumberTypeSchema = YupTypeSchema & {\n  type: 'number';\n  min?: number | Reference<number>;\n  max?: number | Reference<number>;\n  lessThan?: number | Reference<number>;\n  moreThan?: number | Reference<number>;\n  sign?: 'positive' | 'negative';\n  integer?: boolean;\n  oneOf?: number[];\n  notOneOf?: number[];\n  round?: 'floor' | 'ceil' | 'trunc' | 'round';\n  nullable?: boolean;\n  errors?: YupTypeErrors & {\n    min?: string;\n    max?: string;\n    lessThan?: string;\n    moreThan?: string;\n    positive?: string;\n    negative?: string;\n    integer?: string;\n    oneOf?: string;\n    notOneOf?: string;\n  };\n  when?: WhenSchema<NumberTypeSchema>[];\n};\n")),Object(o.b)("h3",{id:"ref"},"Ref"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"ref")," is helpful in case you compare value of dependent field, currently ref support min, max, lessThan, moreThan"),Object(o.b)("p",null,"etc:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"const json = {\n  type: 'object',\n  properties: {\n    min_length: {\n      type: 'number',\n      min: 1,\n      max: 255\n    },\n    max_length: {\n      type: 'number',\n      min: { ref: 'min_length' }\n    }\n  }\n};\n")),Object(o.b)("h2",{id:"object"},"Object"),Object(o.b)("p",null,"Converting a string type json schema to a yup object will return an object the equivalent of ",Object(o.b)("inlineCode",{parentName:"p"},"yup.object()")," with all of the additional validation configuration."),Object(o.b)("h3",{id:"usage-4"},"Usage"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"import { toYup, ObjectTypeSchema } from '@metafox/json2yup';\nimport * as yup from 'yup';\n\nconst schema: ObjectTypeSchema = {\n  type: 'object',\n  strict: true,\n  properties: {\n    firstName: {\n      type: 'string',\n      minLength: 2,\n      strict: true,\n      required: true,\n      errors: {\n        minLength: 'first name too short',\n        required: 'first name required'\n      }\n    },\n    lastName: {\n      type: 'string',\n      minLength: 2,\n      strict: true,\n      required: true,\n      errors: {\n        minLength: 'last name too short',\n        required: 'last name required'\n      }\n    }\n  }\n};\n\nconst yupSchema = toYup(schema);\n\nconsole.log(\n  yupSchema.isValidSync({\n    firstName: 'Bob',\n    lastName: 'Jones'\n  })\n); //true\n\nconsole.log(\n  yupSchema.isValidSync({\n    firstName: 'Bobby',\n    lastName: 'W'\n  })\n); //false\n\n// Equivalent to\n\nconst yupBooleanSchema = yup\n  .object({\n    firstName: yup\n      .string()\n      .min(2, 'first name too short')\n      .required('first name required')\n      .strict(true),\n    lastName: yup\n      .string()\n      .min(2, 'last name too short')\n      .required('last name required')\n      .strict(true)\n  })\n  .strict(true);\n")),Object(o.b)("h3",{id:"type-4"},"Type"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"type ObjectTypeSchema = Omit<YupTypeSchema, 'required'> & {\n  type: 'object';\n  properties: Record<string, TypeSchemas>;\n};\n")),Object(o.b)("h3",{id:"keypath-conversion"},"Keypath Conversion"),Object(o.b)("p",null,"Object property keys containing dots will be automatically converted and nested into child object validation types,"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"../src/tests/types/object/withKeypaths.test.ts"},"Basic Keypath Example"),"."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"../src/tests/types/object/withNestedKeypaths.test.ts"},"Advanced Keypath Example"),".")),Object(o.b)("p",null,"The following example demonstrates how an object definition will be validated once it is converted into a YUP object. It's important to note that this dot notation keypathing can be done at any level of an object type validation schema."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"import { ObjectTypeSchema } from '@metafox/json2yup';\n\n// Property names with dot notation keypaths\n\nconst objectSchema: ObjectTypeSchema = {\n  type: 'object',\n  strict: true,\n  properties: {\n    'user.details.firstName': {\n      type: 'string',\n      required: true\n    }\n  }\n};\n\n// Will actually be converted into this object before being 'YUP-ified'\n\nconst actualObjectSchema: ObjectTypeSchema = {\n  type: 'object',\n  strict: true,\n  properties: {\n    user: {\n      type: 'object',\n      properties: {\n        details: {\n          type: 'object',\n          properties: {\n            firstName: {\n              type: 'string',\n              required: true\n            }\n          }\n        }\n      }\n    }\n  }\n};\n")),Object(o.b)("p",null,"Platform is built-in support object uniqueBy when its direct child of array schema."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"const schema: ObjectTypeSchema = {\n  type: 'array',\n  strict: true,\n  of: {\n    type: 'object',\n    uniqueBy: 'name',\n    error: {\n      uniqueBy: 'name must be unique in list',\n    }\n    properties: {\n      name: {\n        type: 'string'\n      },\n      email: {\n        type: 'string'\n      }\n    }\n  }\n};\n")),Object(o.b)("h2",{id:"string"},"String"),Object(o.b)("p",null,"Converting a string type json schema to a yup object will return an object the equivalent of ",Object(o.b)("inlineCode",{parentName:"p"},"yup.string()")," with all of the additional validation configuration."),Object(o.b)("h3",{id:"usage-5"},"Usage"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"import { toYup, StringTypeSchema } from '@metafox/json2yup';\nimport * as yup from 'yup';\n\nconst schema: StringTypeSchema = {\n  type: 'string',\n  strict: true,\n  required: true,\n  minLength: 5,\n  errors: {\n    minLength: 'My custom min length message',\n    required: 'My custom required message'\n  }\n};\n\nconst yupSchema = toYup(schema);\n\nconsole.log(yupSchema.isValidSync('Hello')); //true\nconsole.log(yupSchema.isValidSync('Hi')); //false\n\n// Equivalent to\n\nconst yupStringSchema = yup\n  .string()\n  .min(5, 'My custom min length message')\n  .required('My custom required message')\n  .strict(true);\n")),Object(o.b)("p",null,"support ref to other field"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"const schema = {\n  type: 'object',\n  properties: {\n    min_password_length: {\n      type: 'number',\n      required: true\n    },\n    password: {\n      type: 'string',\n      minLength: { ref: 'min_password_length' }\n    }\n  }\n};\n")),Object(o.b)("h3",{id:"type-5"},"Type"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"type StringTypeSchema = YupTypeSchema & {\n  type: 'string';\n  minLength?: number;\n  maxLength?: number;\n  case?: 'lowercase' | 'uppercase';\n  uppercase?: number;\n  matches?: { regex: string; excludeEmptyString?: boolean };\n  format?: 'email' | 'url';\n  oneOf?: string[];\n  notOneOf?: string[];\n  nullable?: boolean;\n  errors?: YupTypeErrors & {\n    minLength?: string;\n    maxLength?: string;\n    lowercase?: string;\n    uppercase?: string;\n    matches?: string;\n    email?: string;\n    url?: string;\n    oneOf?: string;\n    notOneOf?: string;\n  };\n  when?: WhenSchema<StringTypeSchema>[];\n};\n")),Object(o.b)("h2",{id:"when"},"When"),Object(o.b)("p",null,"Yup allows you to alter the validation on your data depending on other values within the validated data payload using the ",Object(o.b)("inlineCode",{parentName:"p"},"when()")," method."),Object(o.b)("p",null,"The test suite contains examples of how ",Object(o.b)("inlineCode",{parentName:"p"},"when")," validation configuration can be used with all the different data types."),Object(o.b)("h3",{id:"type-6"},"Type"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"type WhenSchema<T extends YupTypeSchema> = {\n  fields: string | string[];\n  is: unknown;\n  then: T;\n  otherwise?: T;\n};\n")),Object(o.b)("h2",{id:"custom-errors"},"Custom Errors"),Object(o.b)("p",null,"Every schema type has an optional errors object which allow you to override the default YUP generated error messages for specific failure reasons."),Object(o.b)("p",null,"For example, these are the ",Object(o.b)("a",{parentName:"p",href:"../src/types/index.ts"},"StringTypeSchema")," error message options:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"../src/types/index.ts"},"YupTypeErrors")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"#example"},"Example"))),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"    errors?: YupTypeErrors & {\n        minLength?: string;\n        maxLength?: string;\n        lowercase?: string;\n        uppercase?: string;\n        matches?: string;\n        email?: string;\n        url?: string;\n        oneOf?: string;\n        notOneOf?: string;\n    }\n")),Object(o.b)("h3",{id:"example"},"Example"),Object(o.b)("p",null,"In this example we will set and retrieve our custom Yup error messages, for the ",Object(o.b)("inlineCode",{parentName:"p"},"minLength")," and ",Object(o.b)("inlineCode",{parentName:"p"},"required")," rules. The same can be done for all schema types and all schema type rules. Check the schema type's custom error object type definition for which error messages are available."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-typescript"},"import { toYup, StringTypeSchema } from '@metafox/json2yup';\nimport to from 'await-to-js';\n\nconst schema: StringTypeSchema = {\n  type: 'string',\n  strict: true,\n  required: true,\n  minLength: 5,\n  errors: {\n    minLength: 'My custom min length message',\n    required: 'My custom required message'\n  }\n};\n\nconst yupSchema = toYup(schema);\n\nconst [error] = await to(yupSchema.validate('Hi'));\nconsole.log(error.errors); //[\"My custom min length message\"]\n\nconst [error2] = await to(yupSchema.validate(undefined));\nconsole.log(error2.errors); //[\"My custom required message\"]\n")))}void 0!==m&&m&&m===Object(m)&&Object.isExtensible(m)&&!m.hasOwnProperty("__filemeta")&&Object.defineProperty(m,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/public/frontend/validation.mdx"}}),m.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-public-frontend-validation-mdx-7b8860657a6da33e0d80.js.map